---
title: プレーンなC＃タイプの登録
---

Registerを使用する方法はさまざまです。
以下の複合タイプを例に取ります。

```csharp
class ServiceA : IServiceA, IInputPort, IDisposable { /* ... */ }
```

## 具体的な型の登録

```cs
builder.Register<ServiceA>(Lifetime.Singleton);
```

次のように解決できます：

```csharp
class ClassA
{
    public ClassA(ServiceA serviceA) { /* ... */ }
}
```

## インターフェースとして登録

```csharp
builder.Register<IServiceA, ServiceA>();
```

次のように解決できます：

```csharp
class ClassA
{
    public ClassA(IServiceA serviceA) { /* ... */ }
}
```

## 複数のインターフェースとして登録

```csharp
builder.Register<ServiceA>(Lifetime.Singleton)
    .As<IServiceA, IInputPort>();
```

次のように解決できます：

```csharp
class ClassA
{
    public ClassA(IServiceA serviceA) { /* ... */ }
}

class ClassB
{
    public ClassB(IInputPort inputPort) { /* ... */ }
}
```

## 実装されたすべてのインターフェースを自動的に登録

```csharp
builder.Register<ServiceA>(Lifetime.Singleton)
    .AsImplementedInterfaces();
```

次のように解決できます：

```csharp
class ClassA
{
    public ClassA(IServiceA serviceA) { /* ... */ }
}

class ClassB
{
    public ClassB(IInputPort inputPort) { /* ... */ }
}
```

## 実装されたすべてのインターフェースと具体的な型の登録

```csharp
builder.Register<ServiceA>(Lifetime.Singleton)
    .AsImplementedInterfaces()
    .AsSelf();
```

次のように解決できます：

```csharp
class ClassA
{
    public ClassA(IServiceA serviceA) { /* ... */ }
}

class ClassB
{
    public ClassB(IInputPort inputPort) { /* ... */ }
}

class ClassC
{
    public ClassC(ServiceA serviceA) { /* ... */ }
}
```

## ライフサイクルマーカーインターフェースの登録

```csharp
class GameController : IStartable, ITickable, IDisposable { /* ... */ }
```

```csharp
builder.RegisterEntryPoint<GameController>();
```

:::note
これは`Register<GameController>(Lifetime.Singleton).AsImplementedInterfaces()`と似ています。
主な違いはPlayerLoopSystemで実行するかどうかです。
:::

エントリーポイントの例外処理をカスタマイズしたい場合は、次のようにコールバックを登録できます。

```csharp
builder.RegisterEntryPointExceptionHandler(ex =>
{
    UnityEngine.Debug.LogException(ex);
    // 追加の処理...
});
```

複数のEntryPointがある場合、グルーピングとして次の宣言を使うことができます。

```csharp
builder.UseEntryPoints(entryPoints =>
{
   entryPoints.Add<ScopedEntryPointA>();
   entryPoints.Add<ScopedEntryPointB>();
   entryPoints.Add<ScopedEntryPointC>().AsSelf();
   entryPoints.OnException(ex => ...)
});
```

これは次のものと同じです：

```csharp
builder.RegisterEntryPoint<ScopedEntryPointA>();
builder.RegisterEntryPoint<ScopedEntryPointB>();
builder.RegisterEntryPoint<ScopedEntryPointC>().AsSelf();
builder.RegisterEntryPointExceptionHandler(ex => ...);
```

詳細は [プレーンC#エントリーポイント](../integrations/entrypoint) をご覧ください。

## インスタンスの登録

```csharp
// ...
var obj = new ServiceA();
// ...

builder.RegisterInstance(obj);
```

:::note
`RegisterIntance`は常に`Singleton`の寿命を持つため、引数はありません。
:::

次のように解決できます：

```csharp
class ClassA
{
    public ClassA(ServiceA serviceA) { /* ... */ }
}
```

:::note
RegisterInstanceで登録されたインスタンスはコンテナによって管理されません。

- Disposeは自動的に実行されません。
- Method Injectionも自動的には実行されません。

コンテナに作成したインスタンスを管理させたい場合は、以下のいずれかを代わりに使用することを検討してみてください。

- [Register(_ => instance, ...)](./register-using-delegate)
- [RegisterComponent(...)](./register-monobehaviour)
:::

## インターフェースとしてインスタンスを登録

`As*`の宣言を使用します。

```csharp
builder.RegisterInstance<IInputPort>(serviceA);

builder.RegisterInstance(serviceA)
    .As<IServiceA, IInputPort>();

builder.RegisterInstance(serviceA)
    .AsImplementedInterfaces();
```

## 型固有のパラメーターの登録

型が一意ではないが、起動時にインジェクトしたい依存関係がある場合、次のようにすることができます：

```csharp
builder.Register<SomeService>(Lifetime.Singleton)
    .WithParameter<string>("http://example.com");
```

または、キーでパラメーターを名付けることができます。

```csharp
builder.Register<SomeService>(Lifetime.Singleton)
    .WithParameter("url", "http://example.com");
```

次のように解決できます：

```csharp
class SomeService
{
    public SomeService(string url) { /* ... */ }
}
```

この登録は`SomeService`にインジェクトされる場合にのみ機能します。

```csharp
class OtherClass
{
    // ! エラー
    public OtherClass(string hogehoge) { /* ... */ }
}
```

## オープンジェネリクスの登録

```csharp
class GenericType<T>
{
    // ...
}
```

```csharp
builder.Register(typeof(GenericType<>), Lifetime.Singleton);
```

次のように解決できます：

```csharp
class SomeService
{
    public SomeService(GenericType<int> closedGenericType) { /* ... */ }
}
```

この場合、具体的な型はランタイムで構築されます。
Unity 2022.1以降のIL2CPPで動作することを確認していますが、古いバージョンでは動的型定義をサポートしていないかもしれません。
