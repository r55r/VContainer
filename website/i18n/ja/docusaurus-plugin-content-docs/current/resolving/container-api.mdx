---
title: Container API
---

`IObjectResolver`を通じて、DIコンテナに直接アクセスすることも可能です。VContainerは`IObjectResolver`を自動的に登録し、それが必要な箇所に注入します。そのため、他の依存オブジェクトと同様に簡単にそれを取得することができます。

例えば:

```csharp
class ClassA
{
    public ClassA(IObjectResolver container)
    {
        // ServiceAとして登録されているオブジェクトを取得（もしくは生成）します。
        // ServiceAとしてサブクラスを登録している場合、ここで取得するのもそのサブクラスです。
        var serviceA = container.Resolve<ServiceA>();
        
        // 関連する全ての依存オブジェクトをfooに注入します。
        // オブジェクトに対して2度注入を行うと、[Inject]と指定されたフィールドは上書きされます。
        container.Inject(foo);

        // このGameObjectとその子孫の全てのMonoBehaviourに依存オブジェクトを注入します。
        // そのGameObjectとMonoBehaviourのアクティブ状態にかかわらず注入が行われます。
        container.InjectGameObject(gameObject);

        // 既存のプレハブからGameObjectを生成し、
        // そのMonoBehavioursおよびその子孫に依存オブジェクトを注入します。
        // もしAddressablesから生成する場合など他の方法でGameObjectを生成する場合は、
        // InjectGameObjectの使用を検討してください。
        var object1 = container.Instantiate(prefab);

        // また、Object.Instantiateのような機能を真似したメソッドも提供されています。
        var object2 = container.Instantiate(prefab, parent);
        var object3 = container.Instantiate(prefab, position, rotation, parent);
    }
}
```

特定のパターンで`IObjectResolver.Inject`をよく利用する場合、それに対する[拡張メソッド](https://learn.microsoft.com/ja-jp/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)を作成することを検討できます。実際、ほとんど全ての`IObjectResolver`のAPIは拡張メソッドで提供されています（上記のコードサンプルを含む）。

:::tip
通常、他の注入方法があなたのニーズに合わない場合、またはVContainerのコールバック（例えば、[Register Callbacks](../registering/register-callbacks)や[特定のファクトリ関数](../registering/register-factory#register-func-factory-that-requires-container-dependencies-and-runtime-parameters)）を使用している場合にのみ、`IObjectResolver.Resolve`を明示的に使用してください。すべての解決テクニックは[Pre IL Code Generation](../optimization/codegen)を使用する場合、同等の性能を有しますが、`Resolve`を直接使用することで、コード量が増え、意図が不明確になる可能性があります。
:::

`LifetimeScope`はそのプロパティである`Container`を通じて`IObjectResolver`の参照を保持しています。VContainerもこれを自動的に登録しますが、コンテナが作成された後で頻繁に必要とはならないでしょう。

```csharp
class ClassA
{
    public ClassA(LifetimeScope currentScope)
    {
        // 必要であればLifetimeScopeを注入できますが、
        // この場合、単にServiceAを注入するだけで十分でしょう。
        var foo = currentScope.Container.Resolve<ServiceA>();
    }
}
```
